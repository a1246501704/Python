\一、介绍
计算机系统分为：计算机硬件，操作系统，应用程序三部分。
我们用python或其他语言编写的应用程序若想要把数据永久保存下来，必须要保存于硬盘中，这就涉及到应用程序要操作硬件，
众所周知，应用程序是无法直接操作硬件的，这就用到了操作系统。操作系统把复杂的硬件操作封装成简单的接口给用户/应用程序使用，
其中文件就是操作系统提供给应用程序来操作硬盘虚拟概念，用户或应用程序通过操作文件，可以将自己的数据永久保存下来。
有了文件的概念，我们无需再去考虑操作硬盘的细节，只需要关注操作文件的流程：

# 1. 打开文件，得到文件句柄并赋值给一个变量
# 2. 通过句柄对文件进行操作
# 3. 关闭文件

\二、在python中
# 1. 打开文件，得到文件句柄并赋值给一个变量
f=open('a.txt','r',encoding='utf-8') # 默认打开模式就为r,open是执行了一个系统调用。encoding的意思是告诉操作系统(不是python解释器)使用utf-8字符编码打开文件。
# 2. 通过句柄对文件进行操作
data=f.read()
# 3. 关闭文件
f.close() 

\三、f=open('a.txt','r')的过程分析
# 1、由应用程序向操作系统发起系统调用open(...)
# 2、操作系统打开该文件（操作系统的编码很重要），并返回一个文件句柄给应用程序。
# 3、应用程序将文件句柄赋值给变量f

\四、强调！！
# 强调第一点：资源回收
打开一个文件包含两部分资源：操作系统级打开的文件+应用程序的变量。在操作完毕一个文件时，必须把与该文件的这两部分资源一个不落地回收，回收方法为：
1、f.close() # 回收操作系统级打开的文件
2、del f     # 回收应用程序级的变量

其中del f 一定要发生在f.close()之后，否则就会导致操作系统打开的文件还没有关闭，白白占用资源，
而python自动的垃圾回收机制决定了我们无需考虑del f，这就要求我们，在操作完毕文件后，一定要记住f.close()

虽然我这么说，但是很多同学还是会很不要脸地忘记f.close(),对于这些不长脑子的同学，我们推荐傻瓜式操作方式: 使用with关键字来帮我们管理上下文
with open('a.txt','w') as f:
    pass
 
with open('a.txt','r') as read_f,open('b.txt','w') as write_f:
    data=read_f.read()
    write_f.write(data)

# 强调第二点：字符编码
f=open(...)是由操作系统打开文件，那么如果我们没有为open指定编码，那么打开文件的默认编码很明显是操作系统说了算了，操作
系统会用自己的默认编码去打开文件，在windows下是gbk，在linux下是utf-8。
这就用到了上节课讲的字符编码的知识：若要保证不乱码，文件以什么方式存的（编码），就要以什么方式打开（解码）。
f=open('a.txt','r',encoding='utf-8')

# 打开
f=open('a.txt',mode='r',encoding='utf-8')
# 读/写
data=f.read() # read()会读取文件全部内容
print(data)
# 关闭
del f  # 回收python资源
f.close() # 回收操作系统的资源，因为已经del了。这里会报错。
del f
print(f)

其中 del f 一定要发生在 f.close() 之后，否则就会导致操作系统打开的文件还没有关闭，白白占用资源，
而python自动的垃圾回收机制决定了我们无需考虑 del f，这就要求我们，在操作完毕文件后，一定要记住f.close()。
虽然我这么说，但是很多同学还是会很不要脸地忘记f.close(),对于这些不长脑子的同学，我们推荐傻瓜式操作方式：使用with关键字来帮我们管理上下文。

\上下文管理with
with open('a.txt',mode='r',encoding='utf-8') as f:
    print(f.read())

with open('a.txt','w') as f:
    pass

with open('a.txt','r') as read_f,open('b.txt','w') as write_f: # 同时打开多个文件
    data=read_f.read()
    write_f.write(data)

注意两点：
# 1: 打开一个文件对应两部分:
   一个Python级别的文件句柄
   另外一个是操作系统打开的文件（默认打开文件的编码是以操作系统的编码为准的，除非open()指定encoding='编码'）
# 2: 当文件操作完毕后，应该回收两部分资源:
   del f:   回收应用程序资源（python解释器自动的垃圾回收机制已经替我们做了）
   f.close: 回收操作系统。




