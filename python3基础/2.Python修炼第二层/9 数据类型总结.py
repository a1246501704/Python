按存储空间的占用分（从低到高）
# 数字：可存放一个值，不可变
# 字符串：可存放一个值，需要存索引相关信息，不可变
# 集合：可存放多个值，无序，即无序存索引相关信息,可变。也可以通过使用frozenset创建不可变集合。
# 元组：可存放多个值，有序，需要存索引相关信息，不可变
# 列表：可存放多个值，有序，需要存索引相关信息，可变，需要处理数据的增删改
# 字典：可存放多个值，无序，需要存key与value映射的相关信息，可变，需要处理数据的增删改

按存值个数区分
# 标量／原子类型	数字，字符串
# 容器类型	       列表，元组，字典，集合
 
按可变不可变区分
# 可变	    列表，字典 —— 不可哈希
# 不可变	数字，字符串，元组  —— 可哈希

按访问顺序区分
# 直接访问	          数字
# 顺序访问（序列类型）	字符串，列表，元组
# key值访问（映射类型）	字典

什么是可变对象，什么是不可变对象：
# 可变对象是指，一个对象在不改变其所指向的地址的前提下，可以修改其所指向的地址中的值；
# 不可变对象是指，一个对象所指向的地址上值是不能修改的，如果你修改了这个对象的值，那么它指向的地址就改变了，相当于你把这个对象指向的值复制出来一份，然后做了修改后存到另一个地址上了，但是可变对象就不会做这样的动作，而是直接在对象所指的地址上把值给改变了，而这个对象依然指向这个地址。

浅拷贝
# 1、对于 不可 变类型 Number String Tuple,浅复制仅仅是地址指向，不会开辟新空间。
# 2、对于 可 变类型 List、Dictionary、Set，浅复制会开辟新的空间地址(仅仅是最顶层开辟了新的空间，里层的元素地址还是一样的)，进行浅拷贝
# 3、浅拷贝后，改变原始对象中为可变类型的元素的值，会同时影响拷贝对象的；改变原始对象中为不可变类型的元素的值，只有原始类型受影响。

深拷贝
# 1、浅拷贝，除了顶层拷贝，还对子元素也进行了拷贝（本质上递归浅拷贝）
# 2、经过深拷贝后，原始对象和拷贝对象所有的元素地址都没有相同的了

举例说明：
#encoding=utf-8
import copy
a=[1,2,3,4,5,['a','b']]
#原始对象
b=a               # 赋值，传对象的引用
c=copy.copy(a)    # 对象拷贝，浅拷贝
d=copy.deepcopy(a)# 对象拷贝，深拷贝
print "a=",a,"    id(a)=",id(a),"id(a[5])=",id(a[5])
print "b=",b,"    id(b)=",id(b),"id(b[5])=",id(b[5])
print "c=",c,"    id(c)=",id(c),"id(c[5])=",id(c[5])
print "d=",d,"    id(d)=",id(d),"id(d[5])=",id(d[5])
print "*"*70

a.append(6)#修改对象a
a[5].append('c')#修改对象a中的['a','b']数组对象
print "a=",a,"    id(a)=",id(a),"id(a[5])=",id(a[5])
print "b=",b,"    id(b)=",id(b),"id(b[5])=",id(b[5])
print "c=",c,"    id(c)=",id(c),"id(c[5])=",id(c[5])
print "d=",d,"    id(d)=",id(d),"id(d[5])=",id(d[5])

也可以这样理解：
深拷贝就是完全跟以前就没有任何关系了，原来的对象怎么改都不会影响当前对象
浅拷贝，原对象的list元素改变的话会改变当前对象，如果当前对象中list元素改变了，也同样会影响原对象。
浅拷贝就是藕断丝连
深拷贝就是离婚了

 