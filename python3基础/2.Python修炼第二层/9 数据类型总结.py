按存储空间的占用分（从低到高）
# 数字：可存放一个值，不可变,无索引
# 字符串：可存放一个值，需要存索引相关信息，不可变
# 元组：可存放多个值，有序，需要存索引相关信息，不可变
# 列表：可存放多个值，有序，需要存索引相关信息，可变，需要处理数据的增删改
# 字典：可存放多个值，无序，需要存key与value映射的相关信息，可变，需要处理数据的增删改
# 集合：可存放多个值，无序，即无序存索引相关信息,可变。也可以通过使用frozenset创建不可变集合。

按存值个数区分
# 标量／原子类型	数字，字符串
# 容器类型	       列表，元组，字典，集合
 
按可变不可变区分
# 可变	    列表，字典，集合 —— 不可哈希
# 不可变	数字，字符串，元组  —— 可哈希

按访问顺序区分
# 直接访问	          数字
# 顺序访问（序列类型）	字符串，列表，元组
# key值访问（映射类型）	字典

什么是可变对象，什么是不可变对象：
# 可变对象是指，一个对象在不改变其所指向的地址的前提下，可以修改其所指向的地址中的值；
# 不可变对象是指，一个对象所指向的地址上值是不能修改的，如果你修改了这个对象的值，那么它指向的地址就改变了，相当于你把这个对象指向的值复制出来一份，然后做了修改后存到另一个地址上了，但是可变对象就不会做这样的动作，而是直接在对象所指的地址上把值给改变了，而这个对象依然指向这个地址。

举例说明--可变类型赋值：列表、字典、集合
====s1是可变类型列表，s1赋值给s2，然后修改s1，s2就会跟着改变
s1 = [1,2,3]
s2 = s1
s1.append(4)
print(s1)    # [1,2,3,4] 
print(s2)    # [1,2,3,4] 

====s3是可变类型字典，s3赋值给s4，然后修改s3，s4就会跟着改变
s3= {"name":"tester"}
s4 = s3
s3["age"] = 18
print(s3)   # {"name":"tester","age":18}
print(s4)   # {"name":"tester","age":18}

====s5是可变类型集合，s5赋值给s6，然后修改s5，s6就会跟着改变
s5= set([1,2,3,4])
s6 = s5
s5.add(5)
print(s5)   # {1,2,3,4,5}
print(s6)   # {1,2,3,4,5}

如果是可变(mutable)类型，比如列表、字典、集合，修改其中一个，另一个必定改变
如果是不可变类型(immutable)，比如数字、字符串、元组，修改了其中一个，另一个并不会变

举例说明--不可变类型赋值：数字、字符串、元组
====s1是不可变类型数字，s1赋值给s2，然后修改s1，s2不会跟着改变
s1 = 10
s2 = s1
s1=12
print(s1)  # 12
print(s2)  # 10

====s3是不可变类型字符串，s3赋值给s4，然后修改s3，s4不会跟着改变
s3 = "testing"
s4 = s3
s3=  "tesing testing"
print(s3) # testing
print(s4) # tesing testing

====s5是不可变类型元组，s5赋值给s6，然后修改s5，s6不会跟着改变
s5 = (1,2,3)
s6 = s5
s5=  (1,2,3,4)
print(s5) # (1,2,3,4)
print(s6) # (1,2,3)



浅拷贝
# 1、对于 不可 变类型 Number String Tuple,浅复制仅仅是地址指向，不会开辟新空间。
# 2、对于 可   变类型 List、Dictionary、Set，浅复制会开辟新的空间地址(仅仅是最顶层开辟了新的空间，里层的元素地址还是一样的)，进行浅拷贝
# 3、浅拷贝后，改变原始对象中为可变类型的元素的值，会同时影响拷贝对象的值；改变原始对象中为不可变类型的元素的值，只有原始类型受影响。
# 4、数据半共享（拷贝第一层的数据，具有自己单独的内存地址；嵌套层即第二层或其他层不拷贝，指向原有的内存地址）
原则
# 只复制一层，他变我不变；其余层，他变我也变。
# 如果只有一层，就相当于深拷贝了

方法-三种
第一种：a = b[:]
第二种：a = b.copy()
第三种：引用copy模块，import copy  |  a = copy.copy(b)

举例--浅拷贝
import copy
s1 = [1,2,3,[4,5,6]]
#浅拷贝 切片
s2 = s1[:]

#s1第一层改变，s2不会跟着改变
s1[2] = 55
print(s1) # [1,2,55,[4,5,6]]
print(s2) # [1,2,3,[4,5,6]]

#s1第二层即嵌套层改变，s2也跟着改变
s1[3][0] = 66
print(s1) # [1,2,55,[66,5,6]]
print(s2) # [1,2,3,[66,5,6]]


深拷贝
# 1、浅拷贝，除了顶层拷贝，还对子元素也进行了拷贝（本质上递归浅拷贝）
# 2、经过深拷贝后，原始对象和拷贝对象所有的元素地址都没有相同的了
# 3、数据完全不共享（复制其数据完完全全放独立的一个内存，完全拷贝，数据不共享）

原则
# 他变我也变。

方法
引用copy模块，import copy  |  a = copy.deepcopy(b)

举例--深拷贝

import copy
s1 = [1,2,3,[4,5,6]]
#深拷贝
s2 = copy.deepcopy(s1)

#s1第一层改变，s2不会跟着改变
s1[2] = 55
print(s1) # [1,2,55,[4,5,6]]
print(s2) # [1,2,3,[4,5,6]]

#s1第二层即嵌套层改变，s2也不会跟着改变
s1[3][0] = 66
print(s1) # [1,2,55,[66,5,6]]
print(s2) # [1,2,3,[4,5,6]]


也可以这样理解：
深拷贝就是完全跟以前就没有任何关系了，原来的对象怎么改都不会影响当前对象
浅拷贝，原对象的list元素改变的话会改变当前对象，如果当前对象中list元素改变了，也同样会影响原对象。
浅拷贝就是藕断丝连
深拷贝就是离婚了

# 案例
import copy 

list1 = [11,22,[33,44]]
list2 = list1
list3 = list1[:]
list4 = copy.copy(list1)
list5 = copy.deepcopy(list1)

list1[2].append(55)
print("list2",list2)  # [11,22,[33,44,55]]
print("list3",list3)  # [11,22,[33,44,55]]
print("list4",list4)  # [11,22,[33,44,55]]
print("list5",list5)  # [11,22,[33,44]]


 